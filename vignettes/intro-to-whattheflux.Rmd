---
title: "Introduction to whattheflux"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to whattheflux}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The `whattheflux` package provides functions to parse static-chamber
greenhouse gas measurement files generated by a variety of instruments; 
compute flux rates using multi-observation metadata; and generate diagnostic
metrics and plots. It's designed to be easy to integrate into scientific workflows.

## Load sample data

```{r setup}
library(whattheflux)

# Data from a LI-7810
f <- system.file("extdata/TG10-01087.data", package = "whattheflux")
dat <- wtf_read_LI7810(f)
dat[1:6, 1:9] # full raw dataset has 500+ rows and 25 columns
```

The analyzer data is basically a stream of timestamps and associated
greenhouse gas concentration measurements:

```{r overview-plot, fig.width=8}
library(ggplot2)
ggplot(dat, aes(TIMESTAMP, CO2)) + geom_point()
```

## Match with metadata

For this to be useful, we need to 
associate it with metadata about the measurements we made: when they started,
how long they lasted, plot/treatment/collar information, etc. 

```{r metadata}
# Accompanying metadata
md <- system.file("extdata/TG10-01087-metadata.csv", package = "whattheflux")
metadat <- read.csv(md)

# Convenience function to fill in missing dead band and observation length info
metadat <- wtf_fill_metadata(metadat)

print(metadat)
```

The `wtf_metadata_match` function matches up the data, using the `TIMESTAMP`
columns that `wtf_read_LI7810` helpfully created when it read the file.

```{r matching, fig.width=8}
dat$metadat_row <- wtf_metadata_match(dat$TIMESTAMP, 
                                      metadat$Date, metadat$Start_time,
                                      metadat$Dead_band, metadat$Obs_length)
dat$Plot <- metadat$Plot[dat$metadat_row]
metadat$metadat_row <- seq_len(nrow(metadat))

# ...and plot
p <- ggplot(dat, aes(TIMESTAMP, CO2, color = Plot)) + geom_point()
print(p)
```

Some of these are clearly not correct--the measurement time seems to be shorter
then 60 seconds for the C, D, and E plots:

```{r emphasize-problems, fig.width=8, echo=FALSE, message=FALSE}
library(lubridate)
p + annotate("rect", ymin = 455, ymax = 476, 
             xmin = ymd_hms("2022-10-27 10:39:30", tz = "EST"), 
             xmax = ymd_hms("2022-10-27 10:43:30", tz = "EST"), 
             color = "red", fill = NA, linewidth = 1.5)
```

In real life we'd want to correct the faulty metadata at its source.
Here, we'll just change the values programmatically and re-match:

```{r matching2, fig.width=8}
metadat$Obs_length[3:5] <- c(30, 45, 45)
dat$metadat_row <- wtf_metadata_match(dat$TIMESTAMP, 
                                      metadat$Date, metadat$Start_time,
                                      metadat$Dead_band, metadat$Obs_length)
dat$Plot <- metadat$Plot[dat$metadat_row]

p %+% dat
```

That looks better!

## Compute fluxes

The `wtf_compute_fluxes` function provides a general-purpose tool for
computing fluxes from concentration time series, as well as associated
QA/QC information.

```{r, fig.width=8}
fluxes <- wtf_compute_fluxes(dat,
                           group_column = "Plot", 
                           time_column = "TIMESTAMP", 
                           conc_column = "CO2")

# By default, wtf_compute_fluxes returns a data.frame with one row per
# grouping variable value (i.e., per measurement). The first column is the
# group label; the second is the average value of the `time_column`;
# and the rest of the columns are fit statistics for a linear fit of
# concentration as a function of time, along with information about polynomial
# and robust-linear fits.

# For clarity, print out only a subset of the columns 
fluxes[c(1:2, 4, 14, 15, 20)]

ggplot(fluxes, aes(Plot, slope_estimate, color = adj.r.squared)) +
  geom_point() +
  geom_linerange(aes(ymin = slope_estimate - slope_std.error,
                     ymax = slope_estimate + slope_std.error))
```

We might want to check whether the robust-linear slope diverges from the
linear fit slope (suggesting influential outliers) or whether the
polynomial R<sup>2</sup> is much larger (potentially indicating curvature 
of the observations due to e.g. diffusion changes).

```{r, figures-side, fig.show="hold", out.width="46%"}
ggplot(fluxes, aes(slope_estimate, slope_estimate_robust, color = Plot)) +
  geom_point() + geom_abline() + theme(legend.position = "none")
ggplot(fluxes, aes(adj.r.squared, r.squared_poly, color = Plot)) +
  geom_point() + geom_abline() + theme(legend.position="none")
```

The plot C (green) data have more scatter, and thus lower R<sup>2</sup> values and
higher uncertainty on the computed flux,
but there's no evidence of nonlinearity or outlier problems.

